//@version=6
indicator("Synapse Sub-Hub: Velocity Layout [Slot A]", overlay=false)

// =============================================================================
// Synapse SUB-HUB: VELOCITY LAYOUT [SLOT A] (Revitalized Bank A)
// =============================================================================
// Replaces the legacy "Order Flow Hub" (Stacked Imbalances).
// Focuses purely on DELTA VELOCITY (Aggression) and LIQUIDITY GAPS.
// Designed to match the 5s speed of the Nitro Node.
// =============================================================================

// --- 1. CONFIGURATION ---
group_velo = "1. Delta Velocity Settings"
velo_lookback = input.int(3, "Velocity Lookback (Bars)", minval=1, group=group_velo)
min_delta_acc = input.float(50.0, "Min Delta Acceleration", minval=10.0, group=group_velo, tooltip="Change in CVD required to trigger velocity spike.")

group_gaps = "2. Liquidity Gap Settings"
detect_gaps = input.bool(true, "Detect Liquidity Gaps", group=group_gaps)
gap_thresh  = input.int(2, "Gap Threshold (Ticks)", minval=1, group=group_gaps, tooltip="Number of ticks skipped without volume.")

group_learn = "3. Bayesian Learning"
win_size    = input.int(10, "Efficacy Window", minval=5, group=group_learn)

// --- 2. DELTA VELOCITY ENGINE ---
// We need lower time frame data for accurate Delta Velocity within the 5s bar
// However, for simplicity and stability in this iteration, we will use the aggregate 5s bar delta
// and measure its rate of change relative to previous bars.

// Calculate Delta
float up_vol = volume * (close >= open ? 1 : 0) // Approximation if no tick data
float dn_vol = volume * (close < open ? 1 : 0)  // Approximation
// Better: Use intrinsic lower timeframe if available, but for now strict 5s aggregate.
// If we had tick data, we'd use request.security_lower_tf. 
// Let's use the standard "Polarity" approximate delta for 5s bars.
float candle_delta = close >= open ? volume * 0.7 : -volume * 0.7 

// Cumulative Delta (Rolling)
var float cvd = 0.0
cvd += candle_delta

// Velocity Calculation (Rate of Change of CVD)
float delta_velocity = ta.change(cvd, velo_lookback)

// Acceleration (Change in Velocity)
float delta_accel = ta.change(delta_velocity)

// Aggression Factor (Velocity vs Volume info)
// High Velocity with Low Volume = Liquidity Vacuum (Gap)
// High Velocity with High Volume = True Aggression

float avg_vol = ta.sma(volume, 50)
bool is_high_vol = volume > avg_vol

// --- 3. LIQUIDITY GAP ENGINE ---
// Detects if price moved significantly with relatively low volume (Vacuum)
float range_size = high - low
float ticks_moved = range_size / syminfo.mintick
float vol_per_tick = ticks_moved > 0 ? volume / ticks_moved : 0.0

// A "Gap" is defined here as low volume per tick during an expansion
float avg_vpt = ta.sma(vol_per_tick, 50)
bool is_gap = detect_gaps and (vol_per_tick < avg_vpt * 0.3) and (ticks_moved > gap_thresh)

// --- 4. SIGNAL GENERATION ---
float final_bias = 0.0
float pulse_strength = 0.0

// Velocity Spike Logic
bool velo_spike_bull = delta_velocity > min_delta_acc
bool velo_spike_bear = delta_velocity < -min_delta_acc

// Acceleration Logic (Turbo)
bool accel_bull = delta_accel > min_delta_acc
bool accel_bear = delta_accel < -min_delta_acc

if velo_spike_bull
    final_bias := 1.0
    pulse_strength := accel_bull ? 2.0 : 1.0
else if velo_spike_bear
    final_bias := -1.0
    pulse_strength := accel_bear ? 2.0 : 1.0
    
// Gap Override (Vacuum sucks price in logic? No, Vacuum means easy move)
// We treat Gap as a "Turbo" modifier for existing direction
if is_gap and final_bias != 0
    pulse_strength := 2.0 // Upgrade to Turbo

// --- 5. AUDIT ENGINE (Bayesian) ---
type NodeState
    float entryPrice = na
    int   direction  = 0
    float[] outcomes

f_audit_node(_bias, _state, _tp_mult) =>
    float _atr = ta.atr(14)
    if not na(_state.entryPrice)
        float dist = _state.direction == 1 ? high - _state.entryPrice : _state.entryPrice - low
        float sl_dist = _state.direction == 1 ? _state.entryPrice - low : high - _state.entryPrice
        
        bool hitTP = dist >= _atr * _tp_mult
        bool hitSL = sl_dist >= _atr * 1.0
        
        if hitTP or hitSL
            array.push(_state.outcomes, hitTP ? 1.0 : 0.0)
            if array.size(_state.outcomes) > win_size
                array.shift(_state.outcomes)
            _state.entryPrice := na
            
    if _bias != 0 and na(_state.entryPrice)
        _state.entryPrice := close
        _state.direction := _bias > 0 ? 1 : -1
        
    array.size(_state.outcomes) > 0 ? array.avg(_state.outcomes) * 100 : 50.0

var s_node = NodeState.new(na, 0, array.new_float(0))
float win_rate = f_audit_node(final_bias, s_node, 1.5)

// --- 6. Axon-Link v3.0 ENCODING ---
// Protocol: 200.PBCCC
float bus_proto = 200.0
float p_digit = pulse_strength
float b_digit = final_bias == 1.0 ? 1.0 : (final_bias == -1.0 ? 2.0 : 0.0)
float c_val   = math.floor(win_rate * 10 + 0.5) 

float Synapse_bus = bus_proto + (p_digit * 0.1) + (b_digit * 0.01) + (c_val / 100000.0)
plot(Synapse_bus, "Velocity Bus Output", display=display.status_line)

// --- DASHBOARD ---
var table hud = table.new(position.middle_right, 3, 6, bgcolor=color.new(color.black, 40), border_width=1)
if barstate.islast
    table.cell(hud, 0, 0, "VELOCITY LAYOUT", text_color=color.aqua)
    table.cell(hud, 1, 0, "VALUE", text_color=color.silver, text_size=size.small)
    table.cell(hud, 2, 0, "STATUS", text_color=color.silver, text_size=size.small)

    table.cell(hud, 0, 1, "CVD Velocity", text_color=color.white, text_halign=text.align_left)
    table.cell(hud, 1, 1, str.tostring(delta_velocity, "#.0"), text_color=delta_velocity > 0 ? color.lime : (delta_velocity < 0 ? color.red : color.gray))
    table.cell(hud, 2, 1, math.abs(delta_velocity) > min_delta_acc ? "SPIKE" : "-", text_color=math.abs(delta_velocity) > min_delta_acc ? color.yellow : color.gray)

    table.cell(hud, 0, 2, "Acceleration", text_color=color.white, text_halign=text.align_left)
    table.cell(hud, 1, 2, str.tostring(delta_accel, "#.0"), text_color=delta_accel > 0 ? color.lime : (delta_accel < 0 ? color.red : color.gray))
    table.cell(hud, 2, 2, math.abs(delta_accel) > min_delta_acc ? "TURBO" : "-", text_color=math.abs(delta_accel) > min_delta_acc ? color.fuchsia : color.gray)

    table.cell(hud, 0, 3, "Liquidity Gap", text_color=color.white, text_halign=text.align_left)
    table.cell(hud, 1, 3, str.tostring(vol_per_tick, "#.0") + "/t", text_color=color.silver)
    table.cell(hud, 2, 3, is_gap ? "VACUUM" : "DENSE", text_color=is_gap ? color.orange : color.gray)

    table.cell(hud, 0, 4, "FINAL OUT", text_color=color.aqua)
    table.cell(hud, 1, 4, final_bias == 1 ? "BULL" : (final_bias == -1 ? "BEAR" : "-"), bgcolor=final_bias == 1 ? color.green : (final_bias == -1 ? color.red : na))
    table.cell(hud, 2, 4, str.tostring(Synapse_bus, "#.####"), text_color=color.gray, text_size=size.tiny)
