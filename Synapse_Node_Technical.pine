//@version=6
indicator("Synapse Sub-Hub: Acceleration [Slot C]", overlay=false)

// =============================================================================
// Synapse SUB-HUB: ACCELERATION [SLOT C] (Revitalized Bank A)
// =============================================================================
// Replaces the legacy "Technical Hub" (MACD/RSI).
// Focuses purely on RATE OF CHANGE (Velocity) and ACCELERATION (Delta Velocity).
// Designed to match the 5s speed of the Nitro Node.
// =============================================================================

// --- 1. CONFIGURATION ---
group_roc = "1. ROC Cluster Settings"
roc_fast_len = input.int(3, "Fast ROC Length", minval=1, group=group_roc)
roc_med_len  = input.int(5, "Medium ROC Length", minval=1, group=group_roc)
roc_slow_len = input.int(8, "Slow ROC Length", minval=1, group=group_roc)
smooth_len   = input.int(2, "Smoothing Length", minval=1, group=group_roc)

group_thresh = "2. Thresholds"
min_velo    = input.float(0.5, "Min Velocity (Points/Bar)", minval=0.1, group=group_thresh)
min_accel   = input.float(0.2, "Min Acceleration (Delta)", minval=0.05, group=group_thresh)
confluence_req = input.int(2, "Required Confluence (x/3)", minval=1, maxval=3, group=group_thresh)

group_learn = "3. Bayesian Learning"
win_size    = input.int(10, "Efficacy Window", minval=5, group=group_learn)

// --- 2. VELOCITY ENGINE ---
f_roc(src, len) => 
    ta.change(src, len)

// Calculate Raw Velocities
raw_v1 = f_roc(close, roc_fast_len)
raw_v2 = f_roc(close, roc_med_len)
raw_v3 = f_roc(close, roc_slow_len)

// Smooth Velocities (Noise Filter)
v1 = ta.ema(raw_v1, smooth_len)
v2 = ta.ema(raw_v2, smooth_len)
v3 = ta.ema(raw_v3, smooth_len)

// Calculate Acceleration (Jerk) -> Change in Velocity
a1 = ta.change(v1)
a2 = ta.change(v2)
a3 = ta.change(v3)

// --- 3. LOGIC GATES ---
// Gate 1: Velocity Threshold
bool gate_v1 = math.abs(v1) > min_velo
bool gate_v2 = math.abs(v2) > min_velo
bool gate_v3 = math.abs(v3) > min_velo

// Gate 2: Acceleration Alignment (Is it speeding up?)
bool acc_bull = a1 > min_accel and a2 > min_accel
bool acc_bear = a1 < -min_accel and a2 < -min_accel

// Gate 3: Alignment Synapse
int score_bull = 0
int score_bear = 0

if v1 > 0 and gate_v1
    score_bull += 1
if v2 > 0 and gate_v2
    score_bull += 1
if v3 > 0 and gate_v3
    score_bull += 1

if v1 < 0 and gate_v1
    score_bear += 1
if v2 < 0 and gate_v2
    score_bear += 1
if v3 < 0 and gate_v3
    score_bear += 1

// --- 4. SIGNAL GENERATION ---
float final_bias = 0.0
float pulse_strength = 0.0

if score_bull >= confluence_req
    final_bias := 1.0
    pulse_strength := acc_bull ? 2.0 : 1.0 // 2.0 = Turbo (Accelerating)
else if score_bear >= confluence_req
    final_bias := -1.0
    pulse_strength := acc_bear ? 2.0 : 1.0

// --- 5. AUDIT ENGINE (Bayesian) ---
type NodeState
    float entryPrice = na
    int   direction  = 0
    float[] outcomes

f_audit_node(_bias, _state, _tp_mult) =>
    float _atr = ta.atr(14)
    if not na(_state.entryPrice)
        float dist = _state.direction == 1 ? high - _state.entryPrice : _state.entryPrice - low
        float sl_dist = _state.direction == 1 ? _state.entryPrice - low : high - _state.entryPrice
        
        bool hitTP = dist >= _atr * _tp_mult
        bool hitSL = sl_dist >= _atr * 1.0
        
        if hitTP or hitSL
            array.push(_state.outcomes, hitTP ? 1.0 : 0.0)
            if array.size(_state.outcomes) > win_size
                array.shift(_state.outcomes)
            _state.entryPrice := na
            
    if _bias != 0 and na(_state.entryPrice)
        _state.entryPrice := close
        _state.direction := _bias > 0 ? 1 : -1
        
    array.size(_state.outcomes) > 0 ? array.avg(_state.outcomes) * 100 : 50.0

var s_node = NodeState.new(na, 0, array.new_float(0))
float win_rate = f_audit_node(final_bias, s_node, 1.5)

// --- 6. Axon-Link v3.0 ENCODING ---
// Protocol: 200.PBCCC
// P = Pulse (1=Standard, 2=Turbo/Accel)
// B = Bias (1=Long, 2=Short)
// C = Confidence (Win Rate)
float bus_proto = 200.0
float p_digit = pulse_strength
float b_digit = final_bias == 1.0 ? 1.0 : (final_bias == -1.0 ? 2.0 : 0.0)
float c_val   = math.floor(win_rate * 10 + 0.5) // 55.5 -> 555

float Synapse_bus = bus_proto + (p_digit * 0.1) + (b_digit * 0.01) + (c_val / 100000.0)
plot(Synapse_bus, "Acceleration Bus Output", display=display.status_line)

// --- DASHBOARD ---
var table hud = table.new(position.bottom_right, 3, 6, bgcolor=color.new(color.black, 40), border_width=1)
if barstate.islast
    table.cell(hud, 0, 0, "ACCELERATION HUB", text_color=color.aqua)
    table.cell(hud, 1, 0, "VELOCITY", text_color=color.silver, text_size=size.small)
    table.cell(hud, 2, 0, "CLUSTER", text_color=color.silver, text_size=size.small)

    table.cell(hud, 0, 1, "Fast (" + str.tostring(roc_fast_len) + ")", text_color=color.white, text_halign=text.align_left)
    table.cell(hud, 1, 1, str.tostring(v1, "#.##"), text_color=v1 > 0 ? color.lime : (v1 < 0 ? color.red : color.gray))
    table.cell(hud, 2, 1, gate_v1 ? "ACTIVE" : "-", text_color=gate_v1 ? color.yellow : color.gray)

    table.cell(hud, 0, 2, "Med (" + str.tostring(roc_med_len) + ")", text_color=color.white, text_halign=text.align_left)
    table.cell(hud, 1, 2, str.tostring(v2, "#.##"), text_color=v2 > 0 ? color.lime : (v2 < 0 ? color.red : color.gray))
    table.cell(hud, 2, 2, gate_v2 ? "ACTIVE" : "-", text_color=gate_v2 ? color.yellow : color.gray)

    table.cell(hud, 0, 3, "Slow (" + str.tostring(roc_slow_len) + ")", text_color=color.white, text_halign=text.align_left)
    table.cell(hud, 1, 3, str.tostring(v3, "#.##"), text_color=v3 > 0 ? color.lime : (v3 < 0 ? color.red : color.gray))
    table.cell(hud, 2, 3, gate_v3 ? "ACTIVE" : "-", text_color=gate_v3 ? color.yellow : color.gray)

    table.cell(hud, 0, 4, "FINAL OUT", text_color=color.aqua)
    table.cell(hud, 1, 4, final_bias == 1 ? "BULL" : (final_bias == -1 ? "BEAR" : "-"), bgcolor=final_bias == 1 ? color.green : (final_bias == -1 ? color.red : na))
    table.cell(hud, 2, 4, pulse_strength == 2.0 ? "TURBO" : "-", text_color=color.fuchsia)
    
    table.cell(hud, 0, 5, "Win Rate", text_color=color.gray)
    table.cell(hud, 1, 5, str.tostring(win_rate, "0") + "%", text_color=win_rate >= 50 ? color.lime : color.red)
    table.cell(hud, 2, 5, str.tostring(Synapse_bus, "#.####"), text_color=color.gray, text_size=size.tiny)
